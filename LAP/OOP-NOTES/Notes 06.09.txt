
Процедурное прог.: Алгоритмическая декомпозиция (Функции)

Парадигма ООП - предварительно анализируем предметную область будущего проекта, выделяем **сущности** и создаем классы для определения этих сущностей в коде программы
Зачем? - в ООП все = объект

Объект = определяется сущность многими переменными

ООПрог.:Объектная декомпозиция (Классы/Объекты)

Киты(Kits) ООП:

**0. Абстракция
1. Инкапсуляция
2. Наследование
3. Полиморфизм**
4. Повторное использование кода
5. Посылка сообщений

Инкапсуляция - логически объеденияет поля и методы в один класс. Появляется состояние объекта в виде закрытой части(private, protected) и интерфейс в виде открытой части(public).

Абстракция является нулевым киток, потому что во всех остальных китах мы достигаем/проявляется во всем остальных китах, и это наша цель.

Класс (class) - конструкция для создания собственных типов. Яркий пример инкапсуляции

class *name* {
    *спецификатор доступа*:
        *Поля класса*
    *спецификатор доступа*:
        *методы класса*
};

Поля класса - переменные, массивы и т.д принадлежащие классу, то из чего состоит объек конкретного вида

Методы класса - функции, принадлежащие классу.

Спецификаторы доступа - определяют уровень доступа данных внутри класса.

public - открытый
private - закрытый (dafault)
protected - защищенный(Используется только при наследовании)

Реализация - закрытая часть класса
Интерфес - публичная/Открытая часть класс

Таким образом инкапсуляции разбивает класс на закрытую и публичную часть класса 

С какой целью закрывается Реализация?
Реализация закрывается для подмены в любой момент, то есть мы закрываем то, что будет меняться в будущем
При изменении Реализации - клиент ничего не заметит, потому что клент имеет доступ только к интерфейсу класса
Клиент Абстрагирован от Реализации при помощи интерфейса

Объект это экземпляр класса(Переменная типа Класс)

Интерфейс класса не меняется, только обнавляется(Новые методы) ex. нельзя  переименовать метод

Методы аксессоры - специальные методы, которые позволяют работать только с определенным полем класса(Get, Set)

Аксессоры которые инициализируют поля - Модификаторами/Сетерами

Методы которые возвращают значение поля класса называются Инспекторами/Геттерами

============================================================

Конструкторы, деструктор и поля указатели

Конструкторы - специальные методы класса, которые вызываются автоматически при создании объекта один раз

*class_name*(par1, par2) {

    *instructions*;
}

Имя конструктора всегда совпадает с именем класса

Конструкторы ничего не возвращают и не имеют типа ретурна

Перегружаются

Дефолтный конструктора = без параметров

Конструкторы позволяют по разному инициализировать объект в момент создания

Деструктор в отличии от Конструктора не принимает никаких параметров и не перегружается. Вызывает автоматически при разрушении объекта

¬*class_name*() {

    *instructions*
}

Поля указатели

Деструкторы вызываются в обратном порядке по сравнению с конструкторами

Зачем нужны деструкторы? Если поле класса ссылается на ресурс вне стека, вызываем деструктор для очищения пямяти

Указатель this (проблема - решение), Вынос методов за пределы класса, многофайловый проект

Указатель this. Класс состоит из полей и методо. Создаем много объектов одного класса(массив), у каждого объекта свои поля(дублируються), а методы одинаковые для всех и нет смысла
их дублировать. Вместо этого существует возможность передачи объекта в метод по указателю - this.

this - неявный параметр, нестатических методов, который указывает на объект, для которого вызван метод(адресс левостороннего объкта инициализирует неявный параметр this)
Таким образом this решает проблему дублирования методов в каждом объекте
Память для всех нестатических методов выделяется при создании первого объекта
this это константный указатель. Нельзя перенаправить на другой объект




Если метод полностью определяется в теле класса, то он является inline методом
Для Реализации обычных методов необходимо:
1. в классе объявить прототипы методов
2. Сам метод создать вне класса по синтаксису

    return_value.*class_name*::*func_name*() {

        *instructions*
    }
