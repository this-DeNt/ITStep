
Процедурное прог.: Алгоритмическая декомпозиция (Функции)

Парадигма ООП - предварительно анализируем предметную область будущего проекта, выделяем **сущности** и создаем классы для определения этих сущностей в коде программы
Зачем? - в ООП все = объект

Объект = определяется сущность многими переменными

ООПрог.:Объектная декомпозиция (Классы/Объекты)

Киты(Kits) ООП:

**0. Абстракция
1. Инкапсуляция
2. Наследование
3. Полиморфизм**
4. Повторное использование кода
5. Посылка сообщений

Инкапсуляция - логически объеденияет поля и методы в один класс. Появляется состояние объекта в виде закрытой части(private, protected) и интерфейс в виде открытой части(public).

Абстракция является нулевым киток, потому что во всех остальных китах мы достигаем/проявляется во всем остальных китах, и это наша цель.

Класс (class) - конструкция для создания собственных типов. Яркий пример инкапсуляции

class *name* {
    *спецификатор доступа*:
        *Поля класса*
    *спецификатор доступа*:
        *методы класса*
};

Поля класса - переменные, массивы и т.д принадлежащие классу, то из чего состоит объек конкретного вида

Методы класса - функции, принадлежащие классу.

Спецификаторы доступа - определяют уровень доступа данных внутри класса.

public - открытый
private - закрытый (dafault)
protected - защищенный(Используется только при наследовании)

Реализация - закрытая часть класса
Интерфес - публичная/Открытая часть класс

Таким образом инкапсуляции разбивает класс на закрытую и публичную часть класса 

С какой целью закрывается Реализация?
Реализация закрывается для подмены в любой момент, то есть мы закрываем то, что будет меняться в будущем
При изменении Реализации - клиент ничего не заметит, потому что клент имеет доступ только к интерфейсу класса
Клиент Абстрагирован от Реализации при помощи интерфейса

Объект это экземпляр класса(Переменная типа Класс)

Интерфейс класса не меняется, только обнавляется(Новые методы) ex. нельзя  переименовать метод

Методы аксессоры - специальные методы, которые позволяют работать только с определенным полем класса(Get, Set)

Аксессоры которые инициализируют поля - Модификаторами/Сетерами

Методы которые возвращают значение поля класса называются Инспекторами/Геттерами

============================================================

Конструкторы, деструктор и поля указатели

Конструкторы - специальные методы класса, которые вызываются автоматически при создании объекта один раз

*class_name*(par1, par2) {

    *instructions*;
}

Имя конструктора всегда совпадает с именем класса

Конструкторы ничего не возвращают и не имеют типа ретурна

Перегружаются

Дефолтный конструктора = без параметров

Конструкторы позволяют по разному инициализировать объект в момент создания

Деструктор в отличии от Конструктора не принимает никаких параметров и не перегружается. Вызывает автоматически при разрушении объекта

¬*class_name*() {

    *instructions*
}

Поля указатели

Деструкторы вызываются в обратном порядке по сравнению с конструкторами

Зачем нужны деструкторы? Если поле класса ссылается на ресурс вне стека, вызываем деструктор для очищения пямяти

Указатель this (проблема - решение), Вынос методов за пределы класса, многофайловый проект

Указатель this. Класс состоит из полей и методо. Создаем много объектов одного класса(массив), у каждого объекта свои поля(дублируються), а методы одинаковые для всех и нет смысла
их дублировать. Вместо этого существует возможность передачи объекта в метод по указателю - this.

this - неявный параметр, нестатических методов, который указывает на объект, для которого вызван метод(адресс левостороннего объкта инициализирует неявный параметр this)
Таким образом this решает проблему дублирования методов в каждом объекте
Память для всех нестатических методов выделяется при создании первого объекта
this это константный указатель. Нельзя перенаправить на другой объект




Если метод полностью определяется в теле класса, то он является inline методом
Для Реализации обычных методов необходимо:
1. в классе объявить прототипы методов
2. Сам метод создать вне класса по синтаксису

    return_value.*class_name*::*func_name*() {

        *instructions*
    }

Статические члены класса, Инициализаторы, Делегирование конструкторов

Статические Члены Класса - Поля и Методы

обычные нестатические поля класса дублируються для каждого объекта, иногда возникает необходимсоть использовать поле которое не будет дублироваться в каждом объекте класса
Такие поля называются Статическими и объявляются с Модификатором static

Память для экземплярных полей(нестатических) выделяется при создании объектов класса
Память для Статических полей - выделяется при объявлении Класса

Статические поля класса объявлються внутри класса, но инициализируются за пределами класса по: 

data_type *class_name*::*var_name* = value;

Если Статические поля находяться в паблике, то к ним можно обращатся через название класса

std::cout << *class_name*::*static_var_name*;

Если Статические поля инкапсулированы в классе(приватные) то для работы с этими полями необходимо создать Статические методы

static data_type *func_name*(); - прототип

Память для Статических методов выделяется при объявлении класса

Статические методы не получают this
Вызов через название класса

В нестатических методах можно использовать Статические поля класса, так как к моменту выделения Памяти для нестатических элементов - Статические поля уже существуют, а наоборот нельзя
Использовать в Статических методах, нестатические данные

Делегирование - означает перенаправление задачи другому специалисту

Делегирование конструкторов - решает проблему дублирования кода

синтаксис делегирования:

*class_name*(par1, par2):*class_name*(par1) {

    *instructions*
}

Конструктор с максимальным кол-вом параметров называет Главным Конструктором

Инициализаторы - механизм который срабатываетпосле создания объекта, но до выполнения тела конструктора. Позволяет инициализировать поля сразу же при объявлении

Какую проблему решают инициализаторы? Если поле константа или ссылка или поле - объект другого класса без конструктора по Дефолту, то обязательно необходимо использовать механизм инициализаторов
для инициализации этих полей

*class_name*(params):*class_field*(param), *class_field*(param)... {

    *instructions*
}

Так же инициализаторы через конструктор главного объкта обращаться к конструктору вложенного объекта

Методы пустого класса, побитовое копирование(проблема/решение), переопределние методов, конструктор копирование

Пустой класс это класс у которого нет методов
В пустом классе - 12 неявных методов:

1.Конструктор по Дефолту
2.Конструктор копирования
3.Деструктор
4.Присваевание с копированием
5.Присваевание с переносом
6.Конструктор переноса
----------------------------------- (Ниже все подходит)
7. new
8. new[]
9. delete
10. delete[]
11. &
12. *

Все эти методы либо ничего не делают(пустое тело), либо выполняют определенное действие
Если поведение стандартного метода нам не подходит - мы можем пявно переопределить метод в своем классе
Конструктор(Дефолт) и деструктор - пустые

При переопределении заголовок метода не меняется - меняется тело

Если какой то метод пустого класса переопределяется программером, то компилятор неявно создавать не будет

Если в классе создается конструктор с параметрами, то Дефолтный не будет создаваться, при необходимости программер явно объвляет

Конструктор копирования создается в классе неявно, автоматически Вызывается при создании копии объкта
По умолчанию этот конструктор выполняет побитовое копировани

Побитовое копирование(поверхностное копирование) - копирование объекта находящихся в стеке. Каждый бит объекта оригинала копируется в соответсвующий бит объета результирующего
Таким образом мы получаем точную копию объекта, находящуюся в стеке
Если объект содержит в себе указаь который ссылается в кучу, то при побитовом копировании все копии объекта будут содержать адресс одного и того же участка в куче
Деструктор будет гарантированно выхываться для каждой копии и при повторном удалении выдаст ошибку на этапе выполнения

4 Случая побитового копирования:

1. Инициализация одного объекта другим в момент создания
2. Передача объекта в метод или функцию по значению
3. возврат объекта из функции или метода по значению
4. Инициализация одного объекта другим после создания

Первые три случая побитового копирования автоматически вызывает конструктор копирования

Если в классе есть поле указатель то для этого класса обязательно необходимо реализовать явный конструктор копирования
Получает константную ссылку на объкт класса

При переопределении конструктора копирования необходимо реальизовать глубокое копирование, то есть для каждой копии будет явно создаваться участок в куче

Параметр конструктора копирования - const *orginal* & *name* - передается для чтения

Ссылка передается в конструктор копирования чтобы не создавать копию объекта, противном случае получим цикличную рекурсию

Explicit конструктор, константные методы класса

Bar() = default; - принудительное создание конструктора по умолчанию с пустым телом

Если в классе есть конструктор с 1 параметром то данный конструктор можно использовать как для инициализации объекта так и для неявного преобразования от стандартного к абстрактному

При необходимости - программист может запретить неявное преобразования с помощью конструктора. Для этого конструктор с 1 параметром объявляется как explicit

Explicit конструктор можно использовать при явном преобразовании

Константные методы - в константном методе класса нельзя Модифицировать обычные поля класса. Для определения констатного метода необходимо после параметров указать const

void getValue() const;

void Bar::getValue() const {

    *instruc
}

Что происхожит когда метод становится константным - влияет на тип указателя this в параметре метода - становится констатным указателем на константу, такой указатель не допускает
изменения полей константы

Mutable - могу меняться в конст методах

void show() const; - (const FOO * const this)
void show(); - (FOO * const this)

Так как констатный метод меняет тип указателя this допускается наличие двух методов в одном классе с одинаковыми прототипами только один будет констатным, а другой нет

Через констатные сущности можно обращаться только к констатным методам

При реализации перегрузки через конст однозначность определяется типом указателя this

Введение в перегрузку операций

Перегрузка операций позволяет реализовать поведение стандартной операции для нестандартных типов

Основные правила перегрузки в С++:

1. Нельзя создавать новые операции
2. Операции которые не перегружаются:
    а) ::
    б) .
    в) ? :
    г) sizeof()
    д) *
    е) &
3. Нельзя поменять приоритет операции

Способы перегрузки в С++:   Метод и Функция

Перегрузка операции, через метод класса - 
public, non static

Бинарные операции - 1 парам. (Левый операнд через this)
Унарные операции - 0 парам., кроме постфиксной формы(++, --)

Перегрузка только через метод: (=, [], (), преобразование типов, ->)

При перегрузке - наш тип всегда слева

*data_type* *operator*(params) {

    *instructions*
}

Перегрузка унарных операций

Префиксная форма ++, --

При перегрузке префиксной формы операторный метод параметров не получает, this указывает на единственный операнд и из метода возвращается сам объект после изменения

Перегрузка операций методом

1. Постфиксный ++, --
2. Сокращенные формы (+=, -=, *=, /=)
3. Логиские операции (>, <, >=, <=)

При перегрузке постфиксных форм ++, -- в качестве параметров передается int как формальный параметр, этот параметр нигде не используется, нужен только для разделения сигнатур

Перегрузка сокращенных форм

Шаблоны классов

initialiser list - это Шаблонный класс, объект которого используется в классах, которые являються коллекциями (Инкапсулируют в себе динамический массив)

Благодаря initialiser list можно передать в качестве параметров конструктора список инициализаторовы без создания массива

*class_name* *obj_name* {1,2,3,4,5};

begin() - указатель на начало массива, end() - указатель на ячейку после конца, size() - возвразает размер массива;

*class_name* (initialiser_list<*template*> param) {

    *instructions*
}

Статические поля в шаблоне класса создаються по одному экземпляру на тип

Статическое поле в шаблоне класса будет дублироваться стротипизированном классе, после этого это обычное статическое поле

Нетиповой аргумент шаблона - при инстанцировании шаблона, как параметр шаблона можно передать строго типизированное значение(передать константу для размера стат. массива)

существуют ли операции, которые перегружаются только через функцию - нет, но есть ситуации когда слева не наш тип например 10 + а, cout << a;

Анализ стринга:

Стринг имеет 18 конструкторов которые позволяют по разному инициализировать объект в момент создания

Методы и перегрузки

at() - символ по указанному индексу

Операторы =, сокращенные формы, ввод вывод, логические операции, индексация

c_str() - конвертация в const char* для работы с фунциями которые не работают со стрингом

replace() - 10 перегрузок

lenght() - кол-во символов в строке

insert() - имеет 8 перегрузок

compare() - сравнение

динамические структуры - это некие конструкции, способные при необходимости 
выделять память под новые элементы или удалять выделенную память для ненужных элементов во время работы программы.

Идеология доступа, Идеология хранения

Идеология доступа:
стек(LIFO)
Очереди: Обычная(FIFO), с приоритетами и кольцевая

Идеология хранения:

массив
Списки: Однозвязный, двусвязный
Дерево: Бинарное Дерево

Идеология доступа - определяет общее правило доступа к элементам вне завиимости от того, как физически информация храниться в памяти

Стек - динамическая структура данных в котором действует принцип LIFO
Вершина стека  это переменная которая всегда указывает на  последний добавленный элемент стека

Основные операции стека: ДОБАВЛЕНИЕ в стек, удаление

Идеолгия хранения данных - это специальные структуры которые определяют способ хранения данных в памяти

int arr[5] = {1,2,3,4,5};
+ Чтение, запись
- Добавление, удаление - постоянное пересоздание, перезапись

Для решения этой проблемы придумали списки - двусвязные, односвязные

Односвязный список - совокупность узлов, каждый из коорых хранит в себе значение и указатель на следующий узел

Узлы расположенны в памяти хаотично и связанны через адреса

В Односвязном списке перебор происходит от начала к концу, так как узел содержит только адрес следующего элемента

У Односвязного списка есть недостаток - нельзя перебирать узлы в обратном направлении

Для решения этой проблемы создали двусвязный список

+Добавление, удаление(без пересоздания)
-Чтение, запись - элементы распологаються хаотично

Что такое поток, понятие потока

Поток - последовательность байт, не зависящих от устройств, с которыми ведется обмен данными

Поток это канал передачи данных

Потоки бывают однонаправленные и двунаправленные

ifstream - чтение из файла
ofstream - запись в файл
fstream - и то и то

Заголовочный файл содержит

Классы в фстриме выполняют следующие функции - создание файла, создание потока, открытие файла, присоединение файла к потоку, обмен данных, отсоедниение потока от файла, закрытие файла, уничтожение потока

in.get() - считывает один символ из файла
in.getline() - считывает строку из файла

out.put() - записыввает один символ в файл
out << - запись строки

Работа с бинарными файлами - write(Откуда, сколько) при открытии файла указываем ios::binary

Отношение между классами:

1. Вложение
2. Агрегация
3. Композиция
4. Дружба
5. Наследование

В ООП - все объект
Перед тем как прогать - принято проектировать систему
Важное значение, при проектировании, имеют отношения между объектами

Основные условия ООПроектирования:

1. Сильное сцепление внутри класса
2. Слабая связанность между классами 

Вложенный класс -(high cohesion) Вид отношения: Является частью внешнего класса. Объявляется внутри другого. Создать объект можно только внутри главного

Дружба - реализует связь: имеет доступ

Агрегация - отношение между объектами: Является частью, но при этом low coupling. При уничтожении одного объекта - другой продолжает жить. Для реализации агрегации
В классе создается указатель на другой объект, сам объект создается вне класса, адрес передается через конструктор

Class Laptop:

    Class CPU - Композиция(High Cohesion)
    Class GPU - Композиция(High Cohesion)
    Class RAM - Композиция(High Cohesion)
    Class SSD - Композиция(High Cohesion)
    Class Keyboard - Композиция(High Cohesion)
    Class TouchPad - Композиция(High Cohesion)
    Class * FlashDrive - Агрегация(Low coupling)
    Class * Mouse - Агрегация(Low coupling)
    Class * Speakers - Агрегация(Low coupling)


Полиморфизм, раннее связывание, позднее связывание

Статический Полиморфизм определяется на этапе компиляции программы(перегрузки, переопределение, шаблоны)

Связывание это этап определенния типа левостороннего объекта и связывание с соответсвующим методом

Ранее связывание определяется на этапе компиляции программы, то есть на этапе компиляции определяется какой метод будет вызван

Указатель на базовый класс может ссылаться на объект своего потомка

Мы как разработчик можем не знать с каким объектом в нашей иерархии будет работать клиент, то есть мы Абстрагированы

Проблема: указатель на базовый класс ссылается на объект в=своего потомка, но из за раннего связывания птр не использует методы потомка

Для решения проблемы надо сделать механизм познего связывания

Виртуальные методы - методы которые создаються в базовом классе и переопределяються в классах потомках необходимо объявить как virtual(указывается перед типом ретурна)

Виртуальными могут быть только переопределенные методы

Позволяют реализовать позднее связывание

механизм позднего связывания

virtual - vptr - vtable - method

Так работает динамический Полиморфизм - один интерфейс множество реализаций 