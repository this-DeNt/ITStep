
Процедурное прог.: Алгоритмическая декомпозиция (Функции)

Парадигма ООП - предварительно анализируем предметную область будущего проекта, выделяем **сущности** и создаем классы для определения этих сущностей в коде программы
Зачем? - в ООП все = объект

Объект = определяется сущность многими переменными

ООПрог.:Объектная декомпозиция (Классы/Объекты)

Киты(Kits) ООП:

**0. Абстракция
1. Инкапсуляция
2. Наследование
3. Полиморфизм**
4. Повторное использование кода
5. Посылка сообщений

Инкапсуляция - логически объеденияет поля и методы в один класс. Появляется состояние объекта в виде закрытой части(private, protected) и интерфейс в виде открытой части(public).

Абстракция является нулевым киток, потому что во всех остальных китах мы достигаем/проявляется во всем остальных китах, и это наша цель.

Класс (class) - конструкция для создания собственных типов. Яркий пример инкапсуляции

class *name* {
    *спецификатор доступа*:
        *Поля класса*
    *спецификатор доступа*:
        *методы класса*
};

Поля класса - переменные, массивы и т.д принадлежащие классу, то из чего состоит объек конкретного вида

Методы класса - функции, принадлежащие классу.

Спецификаторы доступа - определяют уровень доступа данных внутри класса.

public - открытый
private - закрытый (dafault)
protected - защищенный(Используется только при наследовании)

Реализация - закрытая часть класса
Интерфес - публичная/Открытая часть класс

Таким образом инкапсуляции разбивает класс на закрытую и публичную часть класса 

С какой целью закрывается Реализация?
Реализация закрывается для подмены в любой момент, то есть мы закрываем то, что будет меняться в будущем
При изменении Реализации - клиент ничего не заметит, потому что клент имеет доступ только к интерфейсу класса
Клиент Абстрагирован от Реализации при помощи интерфейса

Объект это экземпляр класса(Переменная типа Класс)

Интерфейс класса не меняется, только обнавляется(Новые методы) ex. нельзя  переименовать метод

Методы аксессоры - специальные методы, которые позволяют работать только с определенным полем класса(Get, Set)

Аксессоры которые инициализируют поля - Модификаторами/Сетерами

Методы которые возвращают значение поля класса называются Инспекторами/Геттерами

============================================================

Конструкторы, деструктор и поля указатели

Конструкторы - специальные методы класса, которые вызываются автоматически при создании объекта один раз

*class_name*(par1, par2) {

    *instructions*;
}

Имя конструктора всегда совпадает с именем класса

Конструкторы ничего не возвращают и не имеют типа ретурна

Перегружаются

Дефолтный конструктора = без параметров

Конструкторы позволяют по разному инициализировать объект в момент создания

Деструктор в отличии от Конструктора не принимает никаких параметров и не перегружается. Вызывает автоматически при разрушении объекта

¬*class_name*() {

    *instructions*
}

Поля указатели

Деструкторы вызываются в обратном порядке по сравнению с конструкторами

Зачем нужны деструкторы? Если поле класса ссылается на ресурс вне стека, вызываем деструктор для очищения пямяти

Указатель this (проблема - решение), Вынос методов за пределы класса, многофайловый проект

Указатель this. Класс состоит из полей и методо. Создаем много объектов одного класса(массив), у каждого объекта свои поля(дублируються), а методы одинаковые для всех и нет смысла
их дублировать. Вместо этого существует возможность передачи объекта в метод по указателю - this.

this - неявный параметр, нестатических методов, который указывает на объект, для которого вызван метод(адресс левостороннего объкта инициализирует неявный параметр this)
Таким образом this решает проблему дублирования методов в каждом объекте
Память для всех нестатических методов выделяется при создании первого объекта
this это константный указатель. Нельзя перенаправить на другой объект




Если метод полностью определяется в теле класса, то он является inline методом
Для Реализации обычных методов необходимо:
1. в классе объявить прототипы методов
2. Сам метод создать вне класса по синтаксису

    return_value.*class_name*::*func_name*() {

        *instructions*
    }

Статические члены класса, Инициализаторы, Делегирование конструкторов

Статические Члены Класса - Поля и Методы

обычные нестатические поля класса дублируються для каждого объекта, иногда возникает необходимсоть использовать поле которое не будет дублироваться в каждом объекте класса
Такие поля называются Статическими и объявляются с Модификатором static

Память для экземплярных полей(нестатических) выделяется при создании объектов класса
Память для Статических полей - выделяется при объявлении Класса

Статические поля класса объявлються внутри класса, но инициализируются за пределами класса по: 

data_type *class_name*::*var_name* = value;

Если Статические поля находяться в паблике, то к ним можно обращатся через название класса

std::cout << *class_name*::*static_var_name*;

Если Статические поля инкапсулированы в классе(приватные) то для работы с этими полями необходимо создать Статические методы

static data_type *func_name*(); - прототип

Память для Статических методов выделяется при объявлении класса

Статические методы не получают this
Вызов через название класса

В нестатических методах можно использовать Статические поля класса, так как к моменту выделения Памяти для нестатических элементов - Статические поля уже существуют, а наоборот нельзя
Использовать в Статических методах, нестатические данные

Делегирование - означает перенаправление задачи другому специалисту

Делегирование конструкторов - решает проблему дублирования кода

синтаксис делегирования:

*class_name*(par1, par2):*class_name*(par1) {

    *instructions*
}

Конструктор с максимальным кол-вом параметров называет Главным Конструктором

Инициализаторы - механизм который срабатываетпосле создания объекта, но до выполнения тела конструктора. Позволяет инициализировать поля сразу же при объявлении

Какую проблему решают инициализаторы? Если поле константа или ссылка или поле - объект другого класса без конструктора по Дефолту, то обязательно необходимо использовать механизм инициализаторов
для инициализации этих полей

*class_name*(params):*class_field*(param), *class_field*(param)... {

    *instructions*
}

Так же инициализаторы через конструктор главного объкта обращаться к конструктору вложенного объекта

Методы пустого класса, побитовое копирование(проблема/решение), переопределние методов, конструктор копирование

Пустой класс это класс у которого нет методов
В пустом классе - 12 неявных методов:

1.Конструктор по Дефолту
2.Конструктор копирования
3.Деструктор
4.Присваевание с копированием
5.Присваевание с переносом
6.Конструктор переноса
----------------------------------- (Ниже все подходит)
7. new
8. new[]
9. delete
10. delete[]
11. &
12. *

Все эти методы либо ничего не делают(пустое тело), либо выполняют определенное действие
Если поведение стандартного метода нам не подходит - мы можем пявно переопределить метод в своем классе
Конструктор(Дефолт) и деструктор - пустые

При переопределении заголовок метода не меняется - меняется тело

Если какой то метод пустого класса переопределяется программером, то компилятор неявно создавать не будет

Если в классе создается конструктор с параметрами, то Дефолтный не будет создаваться, при необходимости программер явно объвляет

Конструктор копирования создается в классе неявно, автоматически Вызывается при создании копии объкта
По умолчанию этот конструктор выполняет побитовое копировани

Побитовое копирование(поверхностное копирование) - копирование объекта находящихся в стеке. Каждый бит объекта оригинала копируется в соответсвующий бит объета результирующего
Таким образом мы получаем точную копию объекта, находящуюся в стеке
Если объект содержит в себе указаь который ссылается в кучу, то при побитовом копировании все копии объекта будут содержать адресс одного и того же участка в куче
Деструктор будет гарантированно выхываться для каждой копии и при повторном удалении выдаст ошибку на этапе выполнения

4 Случая побитового копирования:

1. Инициализация одного объекта другим в момент создания
2. Передача объекта в метод или функцию по значению
3. возврат объекта из функции или метода по значению
4. Инициализация одного объекта другим после создания

Первые три случая побитового копирования автоматически вызывает конструктор копирования

Если в классе есть поле указатель то для этого класса обязательно необходимо реализовать явный конструктор копирования
Получает константную ссылку на объкт класса

При переопределении конструктора копирования необходимо реальизовать глубокое копирование, то есть для каждой копии будет явно создаваться участок в куче

Параметр конструктора копирования - const *orginal* & *name* - передается для чтения

Ссылка передается в конструктор копирования чтобы не создавать копию объекта, противном случае получим цикличную рекурсию 